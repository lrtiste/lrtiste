extends ../../layout/main
include ../../partials/code
include ../../partials/content

block content
    style
        include ./samples/progressive-tabs.css
        include ./samples/tabcontent.css
    h1 Tabs component
    blockquote(cite='https://www.w3.org/TR/wai-aria-practices/#tabpanel')
        p A tabbed interface component is a set of layered areas, known as tab panels, where only one area is displayed at a time [...]
    p The user should be able to #[em activate] a tab at a time with keyboard or mouse interactions revealing only the content he/she is interested in.
    section
        h2#contents Contents
        nav
            ul
                +contentEntry('#keyboard','Keyboard interaction')
                +contentEntry('#progressive','Progressive enhancement strategy')
                    ul
                        +contentEntry('#first-step','CSS powered tabs')
                        +contentEntry('#second-step','Javascript enhancement with lrtiste')
                        +contentEntry('#result','Demo: tabs components with radio button')
                +contentEntry('#tabcontent','Tabs as table of content strategy')
                    ul
                        +contentEntry('#tabcontent-first-step','Semantic')
                        +contentEntry('#tabcontent-second-step','Show and hide behaviour with Javascript')
                        +contentEntry('#tabcontent-result','Demo: tabs component as table of content')

    section
        h2#keyboard Keyboard interactions
        P The user should be able to reach the active tab component (ie the header) by pressing #[span TAB] following the regular source flow.
        p Once the tab interface is reached, if the user press #[span TAB] again, the focus will be send to the next focusable element within the active tabpanel until there is not more focusable element so that the focus leaves the component.
        p When the focus is on the tab headers, the user can use the different arrow keys to switch the active tab.
    section
        h2#progressive Progressive enhancement strategy
        p In this strategy we are going to progressively enhance our tab component so it would keep working without javascript while still conveying meaningful semantic and providing relevant keyboard interaction.
        p Note: you should be able to interact with the resulting tab component with Javascript disabled.
        h3#first-step First step: creating a tab component css powered using native html5 elements
        p We use visually hidden (but not hidden for assistive user agents) inputs type radio to provide keyboard interactions. A combination of flexbox properties and sibling selectors then give us the visual aspect expected fo such component.
        p We also add the recommended aria roles so assistive technologies such voice over manages to give more accurate semantic to the user.
        div(data-lrtiste-tabs)
            ul(role='tablist')
                li(role='presentation')
                    a(href='#progressive-1-markup-tabpanel',role='tab', aria-controls='progressive-1-markup-tabpanel', aria-selected='true') Markup
                li(role='presentation')
                    a(href='#progressive-1-css-tabpanel',role='tab', aria-controls='progressive-1-css-tabpanel') Style
            div#progressive-1-markup-tabpanel(role='tabpanel')
                h4(tabindex=0) index.html
                +code('progressive-tabs-1.pug')
                p we can set the attribute #[em checked] to use a different default active tab
            div#progressive-1-css-tabpanel(role='tabpanel')
                h4(tabindex=0) theme.css
                +code('progressive-tabs-1.css')
                p Css selectors are based on semantic rather than arbitrary class names. However the use of adjacent selector forces you to use a given sequence of element in your markup. The #[code progressive-tabs] is here only to scope the style to this specific content. In practice you would use a class name or another data-attribute selector.
        h3#second-step Using #[em lrtiste] to manage aria-states management and keyboard interaction.
        p If Javascript is available we give back to the script the keyboard management as well as the aria states management, which is really easy with #[strong lrtiste] library
        div(data-lrtiste-tabs)
            ul(role='tablist')
                li(role='presentation')
                    a(href='#progressive-markup-tabpanel',role='tab', aria-controls='progressive-markup-tabpanel', aria-selected='true') Markup
                li(role='presentation')
                    a(href='#progressive-css-tabpanel',role='tab', aria-controls='progressive-css-tabpanel') Style
                li(role='presentation')
                    a(href='#progressive-js-tabpanel',role='tab', aria-controls='progressive-js-tabpanel') Script
            div#progressive-markup-tabpanel(role='tabpanel')
                h4(tabindex=0) index.html
                +code('progressive-tabs.pug')
                p The only difference is that we add a #[code aria-selected] attribute on the tab selected by default.
            div#progressive-css-tabpanel(role='tabpanel')
                h4(tabindex=0) theme.css
                +code('progressive-tabs.css')
                p Interestingly, here we don't need to add new style, but only add to the formerly set rules the aria specific selectors
            div#progressive-js-tabpanel(role='tabpanel')
                h4(tabindex=0) index.js
                +code('tabs.js')
                p The code is really simple: we only create an instance of lrtiste tablist with the appropriate HTML element.
                P Note: we could have composed our lrtiste with a behaviour to select by default the tab with the attribute #[em checked] (so there is no need to add the #[code aria-selected] attribute to the default tab)
        h3#result Demo: tabs components with radio button
        include ./samples/progressive-tabs
        p The great thing with this technique is you already have the expected keyboard interaction as well as an acceptable semantic/ui-state phrasing without Javascrit (ie it will work while waiting for the script to load or if an error occurs)
    section
        h2#tabcontent Tabs as table of content strategy
        p The idea is to consider the tab headers as navigation link for you component (as the very same #[a(href="#contents") table of contents] of this page).
        h3#tabcontent-first-step Semantic
        p The tab headers would be a nothing more than a bunch of links targeting sections within our document.
        p We add the related aria-roles and attributes to be more accurate in our semantic. And we make sure our sections are focusable by adding a tabindex to the headers of our sections.
        h4 index.html
        +code('tabcontent.pug')
        h3#tabcontent-second-step Show and hide behaviour with Javascript
        p Although each part of our document remain visible (even without Javascript or without css), the expected show/hide behaviour is lacking. We are going to add some script to implement the keyboard shortcuts and the aria-states management. Then we should be able to use these attributes to implement in css the show/hide features.
        div(data-lrtiste-tabs)
            ul(role='tablist')
                li(role='presentation')
                    a(href='#tabcontent-script', role='tab', aria-controls='tabcontent-script',aria-selected='true') Script
                li(role='presentation')
                    a(href='#tabcontent-style', role='tab', aria-controls='tabcontent-style') Style
            div#tabcontent-style(role='tabpanel')
                h4(tabindex=0) theme.css
                +code('tabcontent.css')
                p Again, we try to use as much as possible semantic css selectors using aria attributes.
                p the #[code #tabcontent-sample] css selector is just used to scope the style to the particular example, in practice you would use a more generic selector
            div#tabcontent-script(role='tabpanel')
                h4(tabindex=0) index.js
                +code('tabcontent.js')
                p We use #[a(href="#stampit") stampit] to compose our widgets with more behaviours. In this case we want to prevent the browser to follow the link related to the tab when Javascript is enabled.
        h3#tabcontent-result Demo: tabs component as table of content
        include ./samples/tabcontent
        p This technique provides a clean semantic approach showing content by default, which makes it accessible. However the keyboard interaction (and the proper tab behaviour) only comes with Javascript.
    script(src='./tabs.js')
