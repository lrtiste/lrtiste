extends ../../layout/main
include ../../partials/code
include ../../partials/content

block content
    style
        include ./samples/checkbox-2.css
        include ./samples/button.css
    h1 Expandable components
    p A lot of components consist in showing/hiding a section. Although they may convey specific semantic or have their particular behaviour like #[a(href='#adf') dropdown menu], #[a(href='#asdfs') accordions] or #[a(href='#adfsd') tabs], at the end, the ability to show/hide a part of the component on demand is quite common. In this tutorial we are going to review several techniques to implement this behaviour in a progressive and accessible way.
    section
        h2#contents Contents
        nav
            ul
                +contentEntry('#keyboard','Keyboard interaction')
                +contentEntry('#checkbox', 'Progressive enhancement using a native html5 checkbox')
                    ul
                        +contentEntry('#checkbox-no-javascript','Without Javascript')
                        +contentEntry('#checkbox-javascript','Javascript enhancement')
                        +contentEntry('#result-checkbox', 'Demo: expandable section with a checkbox')
                +contentEntry('#button', 'Using a button')
                    ul
                        +contentEntry('#result-button','Demo: expandable section using a regular button')

    section
        h2#keyboard Keyboard interaction
        p The common anatomy of such a component is to have a toggle button changing the state of the expanding/collapsing section. The button should be focusable and should respond to the ENTER and SPACE keys (optionally to DOWN and UP arrows) to change the collapsed/expanded state of the corresponding section.
        p What happen then in term of focus and keyboard navigation will depends on the nature of the component (menu, accordion, etc)
    section
        h2#checkbox Progressive enhancement using a native html5 checkbox
        p In this technique we use a checkbox as the button as it already provides the expected keyboard interactions.
        h3#checkbox-no-javascript Without Javascript
        p We hide the visual nature of the checkbox to fake it into a button.
        p We then use css pseudo selectors and adjacent selector to show/hide the section on demand.
        p The main advantage with this technique is that our component has the show/hide behaviour as well as a basic keyboard support even when Javascript is not available.
        div(data-lrtiste-tabs)
            ul(role='tablist')
                li(role='presentation')
                    a(href='#checkbox-1-markup-tab', role='tab',aria-controls='checkbox-1-markup-tab', aria-selected='true') Markup
                li(role='presentation')
                    a(href='#checkbox-1-style-tab', role='tab',aria-controls='checkbox-1-style-tab') Style
            div#checkbox-1-markup-tab(role='tabpanel')
                h4(tabindex=0) index.html
                +code('checkbox.pug')
                p We don't add the role #[em button] to the checkbox as it will be more difficult to convey the expanded/checked state otherwise (without javascript at least)
            div#checkbox-1-style-tab(role='tabpanel')
                h4(tabindex=0) theme.css
                +code('checkbox.css')
                p #[em checkbox-expandable] selector is here to scope the style to our component only. In practice you would use a more generic selector.
                p As we use adjacent selector our markup is bound to the specific sequence input - label - div
        h3#checkbox-javascript Javascript enhancement
        p We are now going to use lrtiste to add the expected keyboard control and to make sure states are updated accordingly to the recommendations.
        div(data-lrtiste-tabs)
            ul(role='tablist')
                li(role='presentation')
                    a(href='#checkbox-2-script-tab', role='tab',aria-controls='checkbox-2-script-tab', aria-selected='true') Script
                li(role='presentation')
                    a(href='#checkbox-2-style-tab', role='tab',aria-controls='checkbox-2-style-tab') Style
            div#checkbox-2-script-tab(role='tabpanel')
                h4(tabindex=0) index.js
                +code('checkbox.js')
                p Now that javascript is available we make sure our checkbox has the more accurate role #[em button]
            div#checkbox-2-style-tab(role='tabpanel')
                h4(tabindex=0) theme.css
                +code('checkbox.css')
                p We keep the same rules but add css selectors based on aria-states
            p At the end, we have a component with more accurate semantic, with synchronised states and with keyboard interactions (ENTER, SPACE, ARROW DOWN, ARROW UP)
        h3#result-checkbox Demo: expandable section with a checkbox
        include ./samples/checkbox
    section
        h2#button Using a button
        p Here, we are going to assume Javascript will be available and we will be using a regular button as toggle control. Content will be displayed by default in case anything goes wrong with the script.
        p Our markup needs to hold all the required aria-roles and aria-attributes, then lrtiste will do the rest !
        div(data-lrtiste-tabs)
            ul(role='tablist')
                li(role='presentation')
                    a(href='#button-markup-tab', role='tab', aria-controls='button-markup-tab', aria-selected='true') Markup
                li(role='presentation')
                    a(href='#button-style-tab', role='tab', aria-controls='button-style-tab') Style
                li(role='presentation')
                    a(href='#button-script-tab', role='tab', aria-controls='button-script-tab') Script
            div#button-markup-tab(role='tabpanel')
                h4(tabindex=0) index.html
                +code('button.pug')
                p all aria roles are set by default.
            div#button-style-tab(role='tabpanel')
                h4(tabindex=0) theme.css
                +code('button.css')
                p We make sure the content is visible by default.
                p Style is scoped to our component for this particular example, in practice you would use more generic scoping selector.
            div#button-script-tab(role='tabpanel')
                h4(tabindex=0) index.js
                +code('button.js')
                p No rocket science here, we just use lrtiste
        h3#result-button Demo: expandable section using a regular button
        include ./samples/button
        p At the end, the component "won't work" without javascript, but on the other hand things are much easier and if we make sure content is displayed by default, it remains accessible to everybody.
        script(src='./expandables.js')




